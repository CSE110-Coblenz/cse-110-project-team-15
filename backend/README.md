# Backend Documentation

This comprehensive guide covers all aspects of the Math Mystery backend API, including architecture, deployment, testing, and development workflows.

---

## Table of Contents
1. [Architecture Overview](#architecture-overview)
2. [Database Schema](#database-schema)
3. [Setup & Deployment](#setup--deployment)
4. [Testing](#testing)
5. [API Reference](#api-reference)
6. [Core Components](#core-components)
7. [Development Workflow](#development-workflow)
8. [Troubleshooting](#troubleshooting)

---

## Architecture Overview

### Tech Stack
- **Framework**: FastAPI (async Python web framework)
- **Database**: PostgreSQL with asyncpg driver
- **Authentication**: JWT (JSON Web Tokens) with HttpOnly cookies
- **Password Hashing**: PBKDF2-SHA256 via passlib
- **Testing**: pytest with pytest-asyncio and testing.postgresql

### Project Structure
```
backend/
├── main.py                 # Application entry point
├── requirements.txt        # Python dependencies
├── pytest.ini             # Pytest configuration
├── core/                  # Core utilities and configuration
│   ├── config.py         # Settings management
│   ├── database.py       # Database connection pooling
│   └── security.py       # Auth & crypto utilities
├── models/               # Pydantic request/response models
│   ├── login.py
│   ├── register.py
│   ├── delete.py
│   ├── save.py
│   └── update.py
├── routers/              # API endpoint handlers
│   ├── login.py
│   ├── logout.py
│   ├── register.py
│   ├── delete.py
│   ├── data.py
│   ├── save.py
│   └── update.py
├── repo/                 # Data access layer
│   └── saves.py
└── tests/               # Integration tests
    ├── conftest.py      # Test fixtures
    ├── test_auth.py     # Auth endpoint tests
    └── test_logout.py   # Logout endpoint tests
```

### Request Flow
1. **Client Request** → Sent to FastAPI endpoint
2. **Router** → Matches URL pattern, extracts dependencies
3. **Database Connection** → Acquired from pool via `get_db_connection()`
4. **Business Logic** → Validates input, processes request
5. **Database Query** → Executes SQL via asyncpg
6. **Response** → Returns Pydantic model as JSON

---

## Database Schema

### Users Table
```sql
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL  -- PBKDF2-SHA256 hashed
);
```

**Fields**:
- `user_id`: Auto-generated integer primary key
- `email`: Unique user email address
- `password`: Hashed password (never store plaintext!)

### Session Table
```sql
CREATE TABLE session (
    session_id TEXT PRIMARY KEY,
    user_id INT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    time_expire TIMESTAMP WITH TIME ZONE
);
```

**Fields**:
- `session_id`: UUID v4 string, generated by backend
- `user_id`: Foreign key to users.user_id
- `is_active`: Boolean flag for session validity
- `time_expire`: Expiration timestamp (auto-calculated)

### Game Saves Table
```sql
CREATE TABLE game_saves (
    user_id INT PRIMARY KEY,
    game_data JSONB
);
```

**Fields**:
- `user_id`: Primary key, foreign key to users.user_id
- `game_data`: JSONB column storing the entire game state (location, notebook, etc.)

**Note**: The backend does NOT auto-create tables. You must manually create these tables before running the application.

### Creating Tables
```sql
-- Run these SQL commands in your PostgreSQL database
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL
);

CREATE TABLE session (
    session_id TEXT PRIMARY KEY,
    user_id INT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    time_expire TIMESTAMP WITH TIME ZONE
);

CREATE TABLE game_saves (
    user_id INT PRIMARY KEY,
    game_data JSONB
);
```

---

## Setup & Deployment

### Prerequisites
- Python 3.10 or higher
- PostgreSQL 12 or higher
- pip (Python package manager)

### Installation Steps

1. **Clone Repository**:
   ```bash
   cd /path/to/cse-110-project-team-15/backend
   ```

2. **Install Dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

3. **Configure Environment**:
   Create a `.env` file in the `backend` directory:
   ```env
   # Database
   DATABASE_URL=postgresql://username:password@localhost:5432/dbname
   
   # Security
   SECRET_KEY=your-secret-key-min-32-chars
   ALGORITHM=HS256
   ACCESS_TOKEN_EXPIRE_MINUTES=30
   
   # Application
   PROJECT_NAME=Math Mystery
   DEBUG=True
   ```

4. **Setup Database**:
   ```bash
   # Connect to PostgreSQL
   psql -U username -d dbname
   
   # Run table creation SQL (see Database Schema section)
   ```

5. **Run Server**:
   ```bash
   uvicorn main:app --reload --host 0.0.0.0 --port 8000
   ```

   The API will be available at `http://localhost:8000`

6. **Verify Installation**:
   ```bash
   curl http://localhost:8000/
   # Expected: {"ok": true}
   ```

### Production Deployment

For production environments:

1. **Disable Debug Mode**:
   ```env
   DEBUG=False
   ```

2. **Use Strong Secret Key**:
   ```bash
   python -c "import secrets; print(secrets.token_urlsafe(32))"
   ```

3. **Run with Gunicorn** (recommended):
   ```bash
   pip install gunicorn
   gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker
   ```

4. **Configure HTTPS**: Use a reverse proxy (nginx, Caddy) with SSL certificates

---

## Testing

### Test Architecture
Tests use `testing.postgresql` to create a temporary, isolated PostgreSQL instance for each test run. This ensures tests don't interfere with your development database.

### Running Tests

```bash
# Install dependencies (including test deps)
pip install -r requirements.txt

# Run all tests
python3 -m pytest backend/tests

# Run with verbose output
python3 -m pytest backend/tests/test_auth.py -v

# Run specific test
python3 -m pytest backend/tests/test_auth.py::test_register_login_delete_flow
```

### Test Coverage

Current tests cover:
- ✅ User registration (success, duplicate email)
- ✅ User login (success, invalid credentials)
- ✅ User deletion (success, invalid credentials)
- ✅ Complete register → login → delete flow
- ✅ Game state saving and retrieval
- ✅ Partial game state updates (location, notebook)
- ✅ Idempotent updates for problems/minigames

### Writing New Tests

Tests are located in `backend/tests/`. To add a new test:

1. Add test function to `test_auth.py`:
   ```python
   @pytest.mark.asyncio
   async def test_my_feature(client: AsyncClient):
       response = await client.post("/endpoint", json={...})
       assert response.status_code == 200
   ```

2. The `client` fixture is provided by `conftest.py` and automatically:
   - Spins up a temporary PostgreSQL database
   - Creates required tables
   - Mocks the database pool
   - Cleans up after each test

---

## API Reference

### Authentication Endpoints

#### POST `/register`
Register a new user account.

**Request**:
```json
{
  "user": "user@example.com",
  "pass": "securepassword"
}
```

**Response** (200 OK):
```json
{
  "ok": true,
  "message": "Successfully Registered"
}
```

**Response** (409 Conflict):
```json
{
  "ok": false,
  "message": "Email already in use"
}
```

**Implementation Details**:
- Password is hashed with PBKDF2-SHA256 before storage
- Email uniqueness is enforced at database level
- No session is created (user must login separately)

---

#### POST `/login`
Authenticate and create a session.

**Request**:
```json
{
  "user": "user@example.com",
  "pass": "securepassword"
}
```

**Response** (200 OK):
```json
{
  "ok": true,
  "message": "Successfully Authorized"
}
```
**Headers**:
```
Set-Cookie: access_token=Bearer eyJ...; HttpOnly; SameSite=Lax; Max-Age=1800
```

**Response** (401 Unauthorized):
```json
{
  "ok": false,
  "message": "Invalid email or password"
}
```

**Implementation Details**:
- Verifies password hash matches stored value
- Generates UUID v4 session ID
- Creates JWT with payload: `{"sub": "user_id", "session_id": "...", "exp": ...}`
- Stores session in database with 30-minute expiration
- Sets HttpOnly cookie (prevents XSS attacks)
- Cookie is `Secure` only in production (not in debug mode)

---

#### POST `/logout`
Invalidate the current session.

**Request**:
Empty body. Requires authentication (cookie).

**Response** (200 OK):
```json
{
  "ok": true,
  "message": "Successfully logged out"
}
```

**Response** (401 Unauthorized):
If not logged in or session expired.

**Implementation Details**:
- Requires valid session cookie
- Deletes the current session from the database
- Clears the `access_token` cookie

---

#### DELETE `/delete`
Delete user account (requires re-authentication).

**Request**:
```json
{
  "user": "user@example.com",
  "pass": "securepassword"
}
```

**Response** (200 OK):
```json
{
  "ok": true,
  "message": "Successfully Deleted"
}
```

**Response** (401 Unauthorized):
```json
{
  "ok": false,
  "message": "Invalid email or password"
}
```

**Implementation Details**:
- Requires password verification (re-authentication)
- Deletes all sessions for the user first
- Then deletes the user record
- Uses database transaction for atomicity

---

### Game State Management

#### POST `/game/save`
Save current game state.

**Request**:
```json
{
  "location": {"room": "Start", "x": 0, "y": 0},
  "notebook": {},
  "access": {},
  "npc": []
}
```

**Response** (200 OK):
```json
{
  "ok": true
}
```

#### GET `/game/sync`
Retrieve saved game state.

**Response** (200 OK):
```json
{
  "location": {"room": "Start", "x": 0, "y": 0},
  "notebook": {},
  "access": {},
  "npc": []
}
```

#### PUT `/game/update`
Update specific parts of the game state (e.g., location, completed problems).

**Request**:
```json
{
  "type": "location",
  "msg": {"room": "Lab", "x": 10, "y": 20}
}
```

**Response** (200 OK):
```json
{
  "ok": true
}
```

---

### Protected Endpoint Pattern

To protect an endpoint with authentication, use the `get_current_user` dependency:

```python
from core.database import get_current_user

@router.get("/protected")
async def protected_endpoint(user_id: int = Depends(get_current_user)):
    # user_id is automatically extracted from cookie
    return {"user_id": user_id}
```

The `get_current_user` dependency:
1. Extracts JWT from `access_token` cookie
2. Verifies JWT signature and expiration
3. Queries database to ensure session is still valid
4. Returns authenticated `user_id`
5. Raises 401 if any step fails

---

### System Endpoints

#### GET/HEAD `/health`
Check API and database status.

**Response** (200 OK):
```json
{
  "ok": true,
  "db_status": "connected"
}
```

---

## Core Components

### `main.py` - Application Entry Point

Initializes the FastAPI application.

**Key Responsibilities**:
- Creates FastAPI app instance
- Configures CORS middleware for frontend
- Registers all routers
- Sets up database pool on startup
- Closes database pool on shutdown

**Startup/Shutdown Hooks**:
```python
@app.on_event("startup")
async def on_startup():
    await init_db_pool()  # Creates asyncpg connection pool

@app.on_event("shutdown")
async def on_shutdown():
    await close_db_pool()  # Gracefully closes all connections
```

**CORS Configuration**:
Allows requests from `http://localhost:3000` (frontend dev server). Update `allow_origins` for production.

---

### `core/config.py` - Settings Management

Uses `pydantic-settings` to load configuration from environment variables.

**Settings**:
- `DATABASE_URL`: PostgreSQL connection string
- `SECRET_KEY`: JWT signing key (keep secret!)
- `ALGORITHM`: JWT algorithm (HS256)
- `ACCESS_TOKEN_EXPIRE_MINUTES`: Session duration
- `DEBUG`: Enable/disable debug mode

**Usage**:
```python
from core.config import settings
print(settings.DATABASE_URL)
```

**Environment Variables**:
Settings can be loaded from `.env` file or system environment variables.

---

### `core/database.py` - Database Connection Management

Manages asyncpg connection pool and provides dependencies.

#### `init_db_pool()`
Creates a global connection pool on application startup.
- **Pool Size**: min=1, max=10 connections
- **Singleton**: Only one pool instance exists

#### `get_db_connection()`
FastAPI dependency that yields a connection from the pool.

**Usage in Endpoints**:
```python
@router.post("/endpoint")
async def endpoint(connection: asyncpg.Connection = Depends(get_db_connection)):
    await connection.fetchrow("SELECT ...")
```

#### `get_current_user()`
FastAPI dependency for authentication.

**Flow**:
1. Reads `access_token` cookie
2. Decodes JWT to extract `session_id`
3. Queries database: `SELECT user_id FROM session WHERE session_id = ? AND time_expire > NOW()`
4. Returns `user_id` if valid, raises 401 otherwise

**Usage**:
```python
@router.get("/protected")
async def protected(user_id: int = Depends(get_current_user)):
    # user_id is authenticated
```

---

### `core/security.py` - Security Utilities

#### `hash_password(password: str) -> str`
Hashes password using PBKDF2-SHA256.

**Example**:
```python
hashed = hash_password("mypassword")
# Returns: "$pbkdf2-sha256$29000$..."
```

#### `verify_password(password: str, hashed: str) -> bool`
Verifies plaintext password against stored hash.

**Example**:
```python
is_valid = verify_password("mypassword", stored_hash)
# Returns: True or False
```

#### `create_access_token(data: dict, expires_delta: Optional[timedelta]) -> str`
Creates a JWT token.

**Example**:
```python
from datetime import timedelta
token = create_access_token(
    data={"sub": "123", "session_id": "abc"},
    expires_delta=timedelta(minutes=30)
)
# Returns: "eyJhbGciOiJI..."
```

#### `verify_token(token: str) -> Optional[dict]`
Decodes and validates JWT.

**Example**:
```python
payload = verify_token(token)
# Returns: {"sub": "123", "session_id": "abc", "exp": ...} or None
```

#### `generate_session_id() -> str`
Generates a UUID v4 session identifier.

**Example**:
```python
session_id = generate_session_id()
# Returns: "550e8400-e29b-41d4-a716-446655440000"
```

---

## Development Workflow

### Adding a New Endpoint

1. **Create Pydantic Models** (`backend/models/feature.py`):
   ```python
   from pydantic import BaseModel
   
   class FeatureRequest(BaseModel):
       field: str
   
   class FeatureResponse(BaseModel):
       ok: bool
       data: str
   ```

2. **Create Router** (`backend/routers/feature.py`):
   ```python
   from fastapi import APIRouter, Depends
   from core.database import get_db_connection
   from models.feature import FeatureRequest, FeatureResponse
   
   feature_router = APIRouter()
   
   @feature_router.post("/feature", response_model=FeatureResponse)
   async def handle_feature(
       payload: FeatureRequest,
       connection = Depends(get_db_connection)
   ):
       # Implementation
       return FeatureResponse(ok=True, data="result")
   ```

3. **Register Router** (`backend/main.py`):
   ```python
   from routers.feature import feature_router
   
   app.include_router(feature_router)
   ```

4. **Write Tests** (`backend/tests/test_feature.py`):
   ```python
   @pytest.mark.asyncio
   async def test_feature(client: AsyncClient):
       response = await client.post("/feature", json={"field": "value"})
       assert response.status_code == 200
   ```

### Code Style Guidelines

- Use `async/await` for all I/O operations
- Use type hints for all function parameters and return values
- Keep routers thin - move business logic to separate modules
- Use Pydantic models for request/response validation
- Follow PEP 8 naming conventions
- Document complex logic with docstrings

### Database Migrations

Currently, the project does not use a migration tool. Schema changes must be applied manually:

1. Write SQL migration script
2. Apply to development database
3. Update test fixtures in `conftest.py`
4. Apply to production database
5. Update documentation

**Future Improvement**: Consider using Alembic for automated migrations.

---

## Troubleshooting

### Common Issues

#### "ModuleNotFoundError: No module named 'X'"
**Solution**: Install dependencies
```bash
pip install -r requirements.txt
```

#### "asyncpg.exceptions.InvalidCatalogNameError"
**Solution**: Database doesn't exist. Create it:
```bash
createdb dbname
```

#### "Cannot connect to database"
**Solution**: Check `DATABASE_URL` in `.env`:
- Verify PostgreSQL is running
- Check username/password
- Verify database exists

#### "401 Unauthorized" on protected endpoints
**Solution**: 
- Ensure you've logged in and received a cookie
- Check cookie is being sent in request
- Verify session hasn't expired (30 min default)

#### Tests fail with "testing.postgresql" errors
**Solution**: Ensure PostgreSQL binaries are in PATH:
```bash
which postgres
# Should show path to postgres binary
```

### Debug Mode

Enable detailed error messages:
```env
DEBUG=True
```

With debug mode:
- FastAPI shows detailed error traces
- CORS is more permissive
- Cookies use `Secure=False` (allows HTTP)

### Logging

Add logging to debug issues:
```python
import logging
logging.basicConfig(level=logging.DEBUG)
```

---

## Additional Resources

- **FastAPI Documentation**: https://fastapi.tiangolo.com/
- **asyncpg Documentation**: https://magicstack.github.io/asyncpg/
- **Pydantic Documentation**: https://docs.pydantic.dev/
- **JWT Specification**: https://jwt.io/

---

## Contributing

When adding features:
1. Create a new branch
2. Write tests first (TDD)
3. Implement feature
4. Update this README
5. Submit pull request

---

**Last Updated**: 2025-12-03  
**Backend Version**: 1.1.0
